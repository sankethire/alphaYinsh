#include "Tree.h"
#include "Node.h"
#include "Move.h"

#include <tuple>
#include <vector>
#include <algorithm>

Tree::Tree() {}

Tree::Tree(Node* rootInput) {
    root = rootInput;
}

Move Tree::pickChild(int indexOfChild) {
    std::tuple<Move, Node*>& moveNodeFromTuple = root->children[indexOfChild];
    Node* nextRootToSet = std::get<1>(moveNodeFromTuple);
    root = nextRootToSet;
    return std::get<0>(moveNodeFromTuple);
}

void Tree::pickChild(Move& moveForObtainingChild) {
    auto seperateMoveCheckEqual = [&] (std::tuple<Move, Node*>& mNTup) {
    return sameMoveInTuple(mNTup, moveForObtainingChild);};

    std::vector<std::tuple<Move, Node*>>::iterator it = 
    std::find_if(root->children.begin(), root->children.end(), 
    seperateMoveCheckEqual);

    if (it != root->children.end()) {
        Node* nextRootToSet = std::get<1>(*it);
    } else {
        // we didn't generate this move in possible moves
        Game& choosenGame = root->gameState.clone();
        Node* choosenNode = new Node(choosenGame, *root);
        root->children.push_back(std::make_tuple(moveForObtainingChild, choosenNode));
        root->childPicked = root->children.size()-1;

        choosenNode->gameState.executeMove(moveForObtainingChild);
        // TODO: chance flips here in case move not found in possible move
        // generated by us
        choosenNode->gameState.chanceFlip();
        root = choosenNode;
    }
}

bool Tree::sameMoveInTuple(std::tuple<Move, Node*> checkThisTuple, Move checkEqualToMove) {
    return (checkEqualToMove == std::get<0>(checkThisTuple));
}
